# Copyright 2022 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Utils for testing EC keys/signatures.

This implementation has been written for testing elliptic curve keys/signatures.
It contains methods for efficient batch computation (rsp. methods that
would be fast if a fast language were used).

This file implements point addition and multiplication of points
on an elliptic curve using both affine and Jacobian coordinates.
Typical implementations of EC arithmetic uses Jacobian coordinates
to avoid modular inversions in the underlying field. EC arithmetic with
affine point representation require an inversion for every point addition.
However, modular inversions can done efficiently in batches. Therefore,
affine representations are preferable to Jacobian coordinates, when the
arithmetic operations can be done in large batches. This method is described
in the paper "Solving a 112-bit Prime Elliptic Curve Discrete
Logarithm Problem on Game Consoles using Sloppy Reduction" by
J. W. Bos, M. E. Kaiharam, T. Kleinjungm, A. K. Lenstra and
P. L. Montgomery (www.joppebos.com/files/noan112.pdf). The paragraph
"Simultaneous inversion" in section 3.1 describes a method that requires about
5 field modular multiplications and 1 square per point.
A method that is even faster than this uses that sometimes both the
addition and subtraction can be used. This case requires about 2.5 modular
multiplications and 1 square per point.

NOTE: The implementations in this file are not suitable for doing EC
cryptography. For example, the implementation lacks counter measures against
timing attacks and it lacks sufficient parameter checks for secure use.
The implementation may even be sloppy if this increases the performance.
For example the paper above describes the use of a sloppy reduction.
"""

import math
from typing import Optional, Union
import gmpy
from paranoid_crypto import paranoid_pb2
from paranoid_crypto.lib import util

# The point at infinity when using affine coordinates.
INFINITY = (None, None)

# The point at infinity when using Jacobian coordinates.
# This representation is not unique. Any triple of the form (z**2, z**3, 0)
# represents the point at infinity. The point at infinity is the only
# point where the last coordinate is 0.
INFINITY_JACOBIAN = (1, 1, 0)

# Type hint for annotating points on a curve.
Coordinate = Optional[int]
EcPoint = Union[tuple[int, int], tuple[None, None]]
EcPointJacobian = tuple[int, int, int]


class EcCurve:
  """An elliptic curve over a prime field in Weierstrass form."""

  def __init__(self,
               name: str,
               a: int,
               b: int,
               mod: int,
               gx: int,
               gy: int,
               n: int,
               h: int = 1):
    """Defines the curve y^2 = x^3 + a * x + b over a prime field.

    Args:
        name: the name of the curve.
        a: a coefficient of the curve equation
        b: a coefficient of the curve equation
        mod: a prime that defines the order of the underlying field
        gx: the x-coordinate of the generator g
        gy: the y-coordinate of the generator g
        n: the order of the generator g
        h: the cofactor (i.e. n*h is the number of points on the curve)
    """
    self.a = gmpy.mpz(a)
    self.b = gmpy.mpz(b)
    self.mod = gmpy.mpz(mod)
    self.g = (gmpy.mpz(gx), gmpy.mpz(gy))
    self.n = gmpy.mpz(n)
    self.name = name
    self.h = h
    # A cache that stores results of the form:
    #   self._cache[k] = self.Multiply(self.g, k)
    # These results are used for batch multiplications.
    self._cache = {}

    # A lookup table for the x-coordinate of the points self.g*i for
    # i < self._table_size.
    self._table = {}
    self._table_size = 0

  def OnCurve(self, p: EcPoint) -> bool:
    """Checks whether the point p is on the curve.

    Args:
       p: the point to check

    Returns:
       True if the point is on the curve, False otherwise
    """
    if p == INFINITY:
      return True
    else:
      x, y = p
      return 0 == ((x * x + self.a) * x + self.b - y * y) % self.mod

  def IsValidPublicKey(self, p: EcPoint) -> bool:
    """Checks whether p is a valid public key.

    A valid public key must satisfy the following checks:
    (1) The point is on the curve
    (2) The public key is not the point at infinity, rsp. the neutral point.
    (3) The point is in the subgroup generated by the generator.
    (4) The affine coordinates x, y are in the range [0, mod - 1]

    Args:
      p: the EC point of the public key

    Returns:
      True if the public key is valid
    """
    if not self.OnCurve(p):
      return False
    if p == INFINITY:
      return False
    # If the cofactor is 1 then all points are generated by the generator, and
    # hence the following step can be skipped.
    if self.h > 1:
      q = self.Multiply(p, self.n)
      if q != INFINITY:
        return False
    x, y = p
    if x < 0 or x > (self.mod - 1) or y < 0 or y > (self.mod - 1):
      return False
    return True

  def Negate(self, p: EcPoint) -> EcPoint:
    """Negates a point on a curve.

    Args:
        p: the point to negate

    Returns:
        the negative point
    """
    if p == INFINITY:
      return p
    x, y = p
    return (x, -y % self.mod)

  def Double(self, p: EcPoint) -> EcPoint:
    """Doubles a point on a curve.

    Args:
        p: a point on the curve

    Returns:
        the point added to itself
    """
    if p == INFINITY:
      return p
    x, y = p
    num = (3 * x * x + self.a) % self.mod
    den = 2 * y
    t = num * gmpy.invert(den, self.mod) % self.mod
    x2 = (t * t - 2 * x) % self.mod
    y2 = (t * (x - x2) - y) % self.mod
    return (x2, y2)

  def Add(self, p: EcPoint, q: EcPoint) -> EcPoint:
    """Point addition.

    Args:
        p: first summand
        q: second summand

    Returns:
        the sum of the two points
    """
    if p == INFINITY:
      return q
    if q == INFINITY:
      return p
    x1, y1 = p
    x2, y2 = q
    if x1 == x2:
      if y1 == y2:
        return self.Double(p)
      else:
        return INFINITY
    inv = gmpy.invert(x1 - x2, self.mod)
    t = (y1 - y2) * inv % self.mod
    x3 = (t * t - x1 - x2) % self.mod
    y3 = (t * (x1 - x3) - y1) % self.mod
    return (x3, y3)

  def Subtract(self, p: EcPoint, q: EcPoint) -> EcPoint:
    """Performs a point subtraction.

    Args:
        p: minuend
        q: subtrahend

    Returns:
        the point difference p - q
    """
    return self.Add(p, self.Negate(q))

  def DoubleJacobian(self, p: EcPointJacobian) -> EcPointJacobian:
    """Doubles a point in Jacobian representation.

    Args:
        p: the point to double.

    Returns:
        2*p
    """
    mod = self.mod
    x, y, z = p
    if z == 0 or y == 0:
      return INFINITY_JACOBIAN
    ysqr = y * y % mod
    zsqr = z * z % mod
    s = 4 * x * ysqr % mod
    if self.a == -3:
      m = 3 * (x + zsqr) * (x - zsqr) % mod
    else:
      m = (3 * x * x + self.a * zsqr * zsqr) % mod
    x2 = (m * m - 2 * s) % mod
    y2 = (m * (s - x2) - 8 * ysqr * ysqr) % mod
    z2 = 2 * y * z % mod
    return x2, y2, z2

  def AddJacobian(self, p: EcPointJacobian,
                  q: EcPointJacobian) -> EcPointJacobian:
    """Adds two points in Jacobian representation.

    Args:
        p: the first point
        q: the second point

    Returns:
        p+q
    """
    mod = self.mod
    if p[2] == 0:
      return q
    if q[2] == 0:
      return p
    x1, y1, z1 = p
    x2, y2, z2 = q
    z1sqr = z1 * z1 % mod
    z2sqr = z2 * z2 % mod
    u1 = x1 * z2sqr % mod
    u2 = x2 * z1sqr % mod
    s1 = y1 * z2 * z2sqr % mod
    s2 = y2 * z1 * z1sqr % mod
    if u1 == u2:
      if s1 != s2:
        return INFINITY_JACOBIAN
      else:
        return self.DoubleJacobian(p)
    h = u2 - u1 % mod
    hsqr = h * h % mod
    hcube = hsqr * h % mod
    r = s2 - s1 % mod
    t = u1 * hsqr % mod
    x3 = (r * r - hcube - 2 * t) % mod
    y3 = (r * (t - x3) - s1 * hcube) % mod
    z3 = h * z1 * z2 % mod
    return x3, y3, z3

  def MultiplyAffine(self, p: EcPoint, n: int) -> EcPoint:
    """Performs a point multiplication using affine coordinates.

       This is generally slower than using Jacobian coordinates,
       hence this function is only used for testing.

    Args:
        p: a point on the curve
        n: the multiplier

    Returns:
        the point n * p
    """
    if n < 0:
      p = self.Negate(p)
      n = -n
    res = INFINITY
    # Loop invariant: The expected result is res + p * n
    while n:
      n, r = divmod(n, 2)
      if r:
        res = self.Add(res, p)
      p = self.Double(p)
    return res

  def AffineToJacobian(self, p: EcPoint) -> EcPointJacobian:
    """Converts a point from affine to Jacobian representation.

    Args:
        p: the point to convert

    Returns:
        the point in Jacobian representation
    """
    if p == INFINITY:
      return INFINITY_JACOBIAN
    else:
      x, y = p
      return (x, y, 1)

  def JacobianToAffine(self, p: EcPointJacobian) -> EcPoint:
    """Converts a point from Jacobian to affine representation.

    Args:
        p: the point to convert

    Returns:
        the point in affine representation

    Raises:
        ValueError: if all coordinates are 0. This indicates an implementation
        error, such as not recognizing a point at infinity or using the
        addition formula for point doubling.
    """
    x, y, z = p
    if z == 0:
      if x == 0 and y == 0:
        raise ValueError("All coordinates zero in Jacobian representation")
      return INFINITY
    mod = self.mod
    w = gmpy.invert(z, mod)
    wsqr = w * w % mod
    wcube = wsqr * w % mod
    x = x * wsqr % mod
    y = y * wcube % mod
    return (x, y)

  def Multiply(self, p: EcPoint, n: int) -> EcPoint:
    """Performs a point multiplication.

    Args:
        p: a point on the curve
        n: the multiplier

    Returns:
        the point n * p
    """
    if p == INFINITY:
      return p
    if n < 0:
      p = self.Negate(p)
      n = -n
    # Trivial case: conversion and back can be avoided
    if n == 1:
      return p
    res = INFINITY_JACOBIAN
    pj = self.AffineToJacobian(p)
    # Loop invariant: The expected result is res + pj * n
    while n:
      n, r = divmod(n, 2)
      if r:
        res = self.AddJacobian(res, pj)
      pj = self.DoubleJacobian(pj)
    return self.JacobianToAffine(res)

  def BatchJacobianToX(self, p_list: list[EcPointJacobian]) -> list[Coordinate]:
    """Returns the x-coordinates of a list of points in Jacobian representation.

    Args:
       p_list: a list of points

    Returns:
       the x-coordinates of the points. The x-coordinate is None for
       the point at INFINITY.
    """
    mod = self.mod
    inverses = self.BatchInverse([p[2] for p in p_list])
    res = [None] * len(p_list)
    for i, p in enumerate(p_list):
      w = inverses[i]
      if w is not None:
        wsqr = w * w % mod
        res[i] = p[0] * wsqr % mod
    return res

  def BatchJacobianToAffine(self,
                            p_list: list[EcPointJacobian]) -> list[EcPoint]:
    """Converts a list of points from Jacobian to affine representation.

    Args:
       p_list: a list of points in Jacobian coordinates

    Returns:
       a list of points in affine coordinates
    """
    mod = self.mod
    inverses = self.BatchInverse([p[2] for p in p_list])
    res = [(None, None)] * len(p_list)
    for i, p in enumerate(p_list):
      w = inverses[i]
      if w is None:
        res[i] = INFINITY
      else:
        wsqr = w * w % mod
        x = p[0] * wsqr % mod
        wcube = wsqr * w % mod
        y = p[1] * wcube % mod
        res[i] = (x, y)
    return res

  def BatchInverse(self, values: list[Coordinate]) -> list[Coordinate]:
    """Computes the inverse of all integers in a list.

    Args:
        values: a list of values for which modular inverses will be computed.
          The list may contain 0 and None, in which case the inverse is None.
          This option simplifies the handling of point lists with special cases
          (such as infinity or point duplications).

    Returns:
        a list of modular inverses

    Raises:
      ArithmeticError: if an internal invariant failed.
    """
    mod = self.mod
    res = [None] * len(values)
    product = 1
    for i, v in enumerate(values):
      if v:
        res[i] = product
        product = product * v % mod
    inverse = gmpy.invert(product, mod)
    for i in range(len(values) - 1, -1, -1):
      v = values[i]
      if v:
        res[i] = res[i] * inverse % mod
        inverse = inverse * v % mod
    # a simple self check
    if inverse != 1:
      raise ArithmeticError("failed invariant")
    return res

  def BatchAddList(self, p_list: list[EcPoint],
                   q_list: list[EcPoint]) -> list[EcPoint]:
    """Computes the sum of two lists of points.

    Args:
        p_list: a list of points
        q_list: a list of points

    Returns:
        The result is the same as [self.Add(p, q) for (p,q) in zip(p_list,
        q_list)].

    Raises:
      ValueError: if the p_list and q_list are of the same size.
    """
    if len(p_list) != len(q_list):
      raise ValueError("length of inputs must be equal")
    size = len(p_list)
    tmp = [None] * size
    for i in range(size):
      p = p_list[i]
      q = q_list[i]
      if p != INFINITY and q != INFINITY:
        tmp[i] = (p[0] - q[0]) % self.mod
    tmp = self.BatchInverse(tmp)
    res = [(None, None)] * size
    for i, v in enumerate(tmp):
      if v is None:
        res[i] = self.Add(p_list[i], q_list[i])
      else:
        p = p_list[i]
        q = q_list[i]
        t = v * (p[1] - q[1]) % self.mod
        x = (t * t - p[0] - q[0]) % self.mod
        y = (t * (p[0] - x) - p[1]) % self.mod
        res[i] = (x, y)
    return res

  def BatchDouble(self, p_list: list[EcPoint]) -> list[EcPoint]:
    """Doubles all points in a list.

    Args:
        p_list: a list of points

    Returns:
        The result is the same as [self.Double(p) for p in p_list].
    """
    size = len(p_list)
    tmp = [None] * size
    for i, p in enumerate(p_list):
      if p != INFINITY:
        tmp[i] = 2 * p[1]
    tmp = self.BatchInverse(tmp)
    res = [(None, None)] * size
    for i, p in enumerate(p_list):
      if tmp[i] is None:
        res[i] = self.Double(p)
      else:
        x, y = p
        num = (3 * x * x + self.a) % self.mod
        t = num * tmp[i] % self.mod
        x2 = (t * t - 2 * x) % self.mod
        y2 = (t * (x - x2) - y) % self.mod
        res[i] = (x2, y2)
    return res

  def BatchAdd(self, p: EcPoint, points: list[EcPoint]) -> list[EcPoint]:
    """Computes the addition of a point and a list of points.

    Args:
        p: a point on the curve
        points: a list of points

    Returns:
        The result is the same as [self.Add(p, q) for q in points].
    """
    if p == INFINITY:
      return points[:]
    tmp = [None] * len(points)
    for i, q in enumerate(points):
      if q != INFINITY:
        tmp[i] = (p[0] - q[0]) % self.mod
    tmp = self.BatchInverse(tmp)
    res = [(None, None)] * len(points)
    for i, v in enumerate(tmp):
      if v:
        t = v * (p[1] - points[i][1]) % self.mod
        x = (t * t - p[0] - points[i][0]) % self.mod
        y = (t * (p[0] - x) - p[1]) % self.mod
        res[i] = (x, y)
      else:
        res[i] = self.Add(p, points[i])
    return res

  def BatchAddX(self, p: EcPoint, points: list[EcPoint]) -> list[Coordinate]:
    """Computes the X-coordinate of the sum of a point and a list of points.

    Args:
        p: a point on the curve
        points: a list of points

    Returns:
        The result is the same as [self.Add(p, q)[0] for q in points].
    """
    if p == INFINITY:
      return [q[0] for q in points]
    tmp = [None] * len(points)
    for i, q in enumerate(points):
      if q != INFINITY:
        tmp[i] = (p[0] - q[0]) % self.mod
    tmp = self.BatchInverse(tmp)
    for i, v in enumerate(tmp):
      if v:
        t = v * (p[1] - points[i][1]) % self.mod
        x = (t * t - p[0] - points[i][0]) % self.mod
        tmp[i] = x
      else:
        tmp[i] = self.Add(p, points[i])[0]
    return tmp

  def BatchAddSubtractX(
      self, p: EcPoint,
      points: list[EcPoint]) -> tuple[list[Coordinate], list[Coordinate]]:
    """Does a batch computation.

       Computes the X-coordinate of the addition and subtraction of a point
       with a list of points. In cases, where the list of points S has a
       symmetric property (i.e. there exist m such that m - v is in S for each
       v in S) this version can be used to compute the points
       (rsp. their x-coordinate) more efficiently.

    Args:
        p: a point on the curve
        points: a list of points

    Returns:
       The result is the same as
         ([self.Add(p, q)[0] for q in points],
          [self.Subtract(p, q)[0] for q in points]).
    """
    if p == INFINITY:
      return [q[0] for q in points], [q[0] for q in points]
    tmp = [None] * len(points)
    for i, q in enumerate(points):
      if q != INFINITY:
        tmp[i] = (p[0] - q[0]) % self.mod
    tmp = self.BatchInverse(tmp)
    sums = [None] * len(points)
    diffs = [None] * len(points)
    for i, v in enumerate(tmp):
      q = points[i]
      if v:
        t = v * (p[1] - q[1]) % self.mod
        sums[i] = (t * t - p[0] - q[0]) % self.mod
        t = v * (p[1] + q[1]) % self.mod
        diffs[i] = (t * t - p[0] - q[0]) % self.mod
      else:
        sums[i] = self.Add(p, q)[0]
        diffs[i] = self.Subtract(p, q)[0]
    return sums, diffs

  def BatchMultiplyG(self, scalars: list[int]) -> list[EcPoint]:
    """Multiplies the generator of this curve by a list of integers.

    This function can be used to compute the public keys corresponding to
    a list of private keys.

    The implementation is based on the paper
    "Algorithms for Multi-exponentiation" by Bodo Moeller, SAC 2001

    Args:
      scalars: some integers

    Returns:
      [self.Multiply(self.g, x) for x in scalars]
    """
    scalars = [x % self.n for x in scalars]

    # Number of bits processed in one step. This will require 2**window_size
    # precomputed points.
    window_size = 8
    steps = (self.n.bit_length() + window_size - 1) // window_size
    mask = sum(1 << j for j in range(0, self.n.bit_length(), steps))
    size = len(scalars)
    for i in range(steps - 1, -1, -1):
      points = [(None, None)] * size
      for j, s in enumerate(scalars):
        multiplier = (s >> i) & mask
        if multiplier not in self._cache:
          self._cache[multiplier] = self.Multiply(self.g, multiplier)
        points[j] = self._cache[multiplier]
      if i == steps - 1:
        res = points
      else:
        res = self.BatchDouble(res)
        res = self.BatchAddList(res, points)
    return res

  def PointSequence(self, base: EcPoint, n: int) -> list[Optional[EcPoint]]:
    """Returns [self.Multiply(base, i) for i in range(n)].

    Args:
      base: a point on the curve
      n: the number of points in the sequence

    Returns:
      a list of points
    """
    base_jac = self.AffineToJacobian(base)
    res = [None] * n
    res[0] = INFINITY_JACOBIAN
    for i in range(1, n):
      res[i] = self.AddJacobian(res[i - 1], base_jac)
    return self.BatchJacobianToAffine(res)

  def PointTable(self, base: EcPoint, n: int) -> dict[int, int]:
    """Returns a dict with {self.Multiply(base, i)[0]:i for i in range(n)}.

    Args:
      base: the base point
      n: the upper bound for the table.

    Returns:
      a lookup table for the x-coordinate of the points base*i
      for i < n.
    """
    # The implementation computes the x-coordinate of the points
    # ((i * m) + j) * base as the sum of precomputed values
    # (i * m) * base and j * base.
    # The precomputed values are two lists of points of size about sqrt(n).
    # A batch addition is used, because the x-cooredinate of the
    # points in affine representation is needed and the batch addtions
    # allow to reduce the number of inversions.
    m = int(math.sqrt(n))
    r = (n + m - 1) // m
    sequence_low = self.PointSequence(base, m)
    sequence_high = self.PointSequence(self.Multiply(base, m), r)
    res = {}
    for i, p in enumerate(sequence_high):
      im = i * m
      for j, x in enumerate(self.BatchAddX(p, sequence_low)):
        res[x] = im + j
    return res

  def BatchDL(self, points: list[EcPoint], n: int) -> list[Optional[int]]:
    """Tries to find small discrete logarithms for a batch of targets.

    The implementation finds discrete logarithms for any point p,
    if self.Multiply(base, x) == p with 0 <= x < n.

    The complexity of this method is O(sqrt(len(points) * n))
    point multiplications.

    Args:
        points: a list of points
        n: an upper bound for the discrete logarithm.

    Returns:
       The result is a list that either contains the discrete logarithms
       or None if the DL could not be bound.
    """
    table_size = int(math.sqrt(n * len(points)))
    base = self.g
    if table_size > self._table_size:
      # TODO(pedroysb): An improvement would be to generate from
      # self._table_size up to table_size.
      self._table = self.PointTable(base, table_size)
      self._table_size = table_size
    # Computes the size of a giant step. This size can be about twice the size
    # of the table above, since the coordinate x in a table represents both
    # a point and its inverse.
    t = 2 * table_size - 1
    # The number of giant steps needs to be 2 larger than n // t, once to offset
    # rounding and once to adjust for the fact that DL might be a difference
    # between a giant step and a baby step.
    giant_steps = 2 + n // t
    list_c = self.PointSequence(self.Multiply(base, -t), giant_steps)
    res = [None] * len(points)
    for i, p in enumerate(points):
      if p == INFINITY:
        res[i] = 0
        continue
      for j, x in enumerate(self.BatchAddX(p, list_c)):
        if x in self._table:
          for dl in [j * t + self._table[x], j * t - self._table[x]]:
            y = self.Multiply(base, dl)
            if y[0] == p[0]:
              if y[1] == p[1]:
                res[i] = dl
              elif y[1] == -p[1] % self.mod:
                res[i] = -dl
    return res

  def ExtendedBatchDL(self, points: list[EcPoint]) -> list[Optional[int]]:
    """Finds the DLs of points assuming the DLs have a special form.

    This method finds the DL x of any points if x has one of the following
    forms:
      (1) Only 4 continuous bytes are set.
      (2) The private key is a repetition of a constant 32-bit value.

    The test is motivated by some research that found such weak keys
    https://www.securityevaluators.com/casestudies/ethercombing/

    An observation used in the method below is that it is sufficient to
    solve DLs for the 32 least significant bits. A point of form (2) can be
    converted into a point of form (1) by a point multiplication with
    2^(-self.bit_length() + 32) modulo the order of the curve.
    A point of form (3) can be converted into a point of form (1) by
    multiplying it with the modular inverse of (1 + 2^32 + 2^64 + ...).

    The method uses two steps. Step 1 generated a list of points with all
    the conversions. Step 2 performs a baby step giant step algorithm with
    all the generated points.

    The time and memory complexity of the methods is
       O(sqrt(#forms * #points * 2^32)).

    Args:
      points: A list of points for which a DL computation is attempted.

    Returns:
      a list containing either the DL of the point or None if the DL
      was not found.
    """
    num_points = len(points)
    # The functions searches for DL of the form i * multipliers[j],
    # with 0 < i < 2**32
    multipliers = []
    bits = self.n.bit_length()
    # 32 bits set in 4 adjacent bytes
    for j in range(0, bits - 31, 8):
      multipliers.append(2**j)
    # Repetition of 32 bit words.
    quad_words = self.n.bit_length() // 32
    for j in range(2, quad_words + 1):
      multipliers.append(sum(2**(32 * i) for i in range(j)))
    inverses = [gmpy.invert(m, self.n) for m in multipliers]
    all_points = [None] * (len(multipliers) * num_points)
    for j, inverse in enumerate(inverses):
      for i, point in enumerate(points):
        all_points[i + num_points * j] = self.Multiply(point, inverse)
    discrete_logs = self.BatchDL(all_points, 2**32)
    res = [None] * num_points
    for k, dlog in enumerate(discrete_logs):
      if dlog is not None:
        res[k % num_points] = int(dlog * multipliers[k // num_points])
    return res

  def BatchDLOfDifferences(self,
                           points: list[EcPoint],
                           other_points: Optional[list[EcPoint]] = None,
                           max_diff: int = 2**24) -> list[Optional[str]]:
    """Finds small DLs of differences between points.

    This functions finds pairs of weak keys with points p and q
    such that p in points and q in points or other points and
    p - q = k * G with abs(k) < max_diff.

    The complexity of this test is
    O(max_diff + len(points) * (len(other_points) + len(points) // 2))

    Args:
      points: the points of the public keys being tested.
      other_points: additional points considered for the differences. For
        example, this can be a list of points that have already been tested. The
        function does not compare points in this list against each other.
      max_diff: the upper bound on the difference of two private keys

    Returns:
      A list of the same length as points. If the i-th element of this list
      is not None, then the discrete log between this key and another
      key has been found and this i-th element is a string describing the
      relation.
    """
    if other_points is None:
      other_points = []
    res = [None] * len(points)
    # Avoids to generate a table when there is nothing to test.
    if not points or len(points) + len(other_points) < 2:
      return res
    base = self.g
    if max_diff > self._table_size:
      # TODO(pedroysb): An improvement would be to generate from
      # self._table_size up to max_diff.
      self._table = self.PointTable(base, max_diff)
      self._table_size = max_diff
    negated = [self.Negate(q) for q in other_points]
    for i, p in enumerate(points):
      for j, x in enumerate(self.BatchAddX(p, negated)):
        if x is None:
          continue  # key is a duplicate
        if x in self._table:
          q = self.Negate(negated[j])
          diff = self.Subtract(p, q)
          for dl in (self._table[x], -self._table[x]):
            diff2 = self.Multiply(base, dl)
            if diff == diff2:
              res[i] = "key - (%x, %x) = %d * G" % (q[0], q[1], dl)
              if j >= len(other_points):
                key2 = j - len(other_points)
                res[key2] = "key - (%x, %x) = %d * G" % (p[0], p[1], -dl)
      negated.append(self.Negate(p))
    return res

  def TransformOrderLen(self, h: int, hlen: int) -> int:
    """Makes h fit the curve order bit length (rfc6979 section-2.4)."""
    shift = hlen - self.n.bit_length()
    if shift > 0:
      h >>= shift
    return h % self.n

  def HiddenNumberParams(self, r: int, s: int, z: int) -> tuple[int, int]:
    """Computes parameters for a hidden number problem from a signature (r,s).

    A hidden number problem for an unknown integer s consists of two lists of
    integers u, v, such that all the elements (u[i] + v[i] * d) % n have some
    kind of bias. A common flaw in the generation of ECDSA signatures is to
    generate the one-time secret value k in a biased manner. This function
    computes an integer pair (a, b) such that k = a + b * d (mod n),
    where d is the private key and k is the one-time secret used to generate
    the signature.

    Args:
      r: the first element of an ECDSA signature.
      s: the second element of an ECDSA signature.
      z: the hash of the message already transformed by self.TransformOrderLen

    Returns:
      an integer pair (a, b) such that k = a + b * d (mod n).
    """
    # k = z * s^(-1) + r * s^(-1) * d (mod n)
    si = gmpy.invert(s, self.n)
    a = z * si % self.n
    b = r * si % self.n
    return (a, b)


def PublicPoint(key: paranoid_pb2.ECKeyInfo) -> tuple[int, int]:
  """Returns the point of the public key.

  Args:
      key: An EC public key. This is a paranoid_pb2.ECKeyInfo protobuf
        containing the x and y attributes.

  Returns:
    A tuple with the x and y coordinate of the public point.
  """
  x = gmpy.mpz(util.Bytes2Int(key.x))
  y = gmpy.mpz(util.Bytes2Int(key.y))
  return (x, y)


def ECDSAValues(sig: paranoid_pb2.ECDSASignatureInfo,
                curve: EcCurve) -> tuple[int, int, int]:
  """Returns a triple (r, s, z) containing values of the ecdsa signature.

  Args:
      sig: An ECDSA signature. This is a paranoid_pb2.ECDSASignatureInfo
        protobuf containing the r, s and message_hash attributes.
      curve: EcCurve of the signature.

  Returns:
    A triple with the r, s and z elements of the signature.
  """
  r = gmpy.mpz(util.Bytes2Int(sig.r))
  s = gmpy.mpz(util.Bytes2Int(sig.s))
  h = gmpy.mpz(util.Bytes2Int(sig.message_hash))
  z = curve.TransformOrderLen(h, len(sig.message_hash) * 8)
  return (r, s, z)


CURVE_FACTORY = {
    paranoid_pb2.CurveType.CURVE_SECP256R1:
        EcCurve(
            name="secp256r1",
            mod=2**256 - 2**224 + 2**192 + 2**96 - 1,
            a=-3,
            b=int(
                "5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2"
                "604b", 16),
            gx=int(
                "6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898"
                "c296", 16),
            gy=int(
                "4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf"
                "51f5", 16),
            n=int("115792089210356248762697446949407573529996955224135760342422"
                  "259061068512044369"),
        ),
    paranoid_pb2.CurveType.CURVE_SECP384R1:
        EcCurve(
            name="secp384r1",
            mod=int(
                "394020061963944792122790401001436138050797392704654466679482"
                "93404245721771496870329047266088258938001861606973112319"),
            a=-3,
            b=int(
                "b3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013"
                "875ac656398d8a2ed19d2a85c8edd3ec2aef", 16),
            gx=int(
                "aa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e08254"
                "2a385502f25dbf55296c3a545e3872760ab7", 16),
            gy=int(
                "3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0"
                "b8c00a60b1ce1d7e819d7a431d7c90ea0e5f", 16),
            n=int("394020061963944792122790401001436138050797392704654466679469"
                  "05279627659399113263569398956308152294913554433653942643"),
        ),
    paranoid_pb2.CurveType.CURVE_SECP192R1:
        EcCurve(
            name="secp192r1",
            mod=2**192 - 2**64 - 1,
            n=int("FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831", 16),
            a=-3,
            b=int("64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1", 16),
            gx=int("188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012", 16),
            gy=int("7192B95FFC8DA78631011ED6B24CDD573F977A11E794811", 16),
        ),
    paranoid_pb2.CurveType.CURVE_SECP224R1:
        EcCurve(
            name="secp224r1",
            mod=2**224 - 2**96 + 1,
            n=int("269599466671506397946670150870196259404578077144243917216827"
                  "22368061"),
            a=-3,
            b=int("b4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4",
                  16),
            gx=int("b70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21",
                   16),
            gy=int("bd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34",
                   16),
        ),
    paranoid_pb2.CurveType.CURVE_SECP521R1:
        EcCurve(
            name="secp521r1",
            mod=int(
                "686479766013060971498190079908139321726943530014330540939446"
                "345918554318339765605212255964066145455497729631139148085803"
                "7121987999716643812574028291115057151"),
            n=int("686479766013060971498190079908139321726943530014330540939446"
                  "345918554318339765539424505774633321719753296399637136332111"
                  "3864768612440380340372808892707005449"),
            a=-3,
            b=int(
                "51953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918e"
                "f109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451f"
                "d46b503f00", 16),
            gx=int(
                "c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b"
                "4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e"
                "31c2e5bd66", 16),
            gy=int(
                "11839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd172"
                "73e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be9"
                "4769fd16650", 16),
        ),
    paranoid_pb2.CurveType.CURVE_SECP256K1:
        EcCurve(
            name="secp256k1",
            mod=2**256 - 2**32 - 977,
            a=0,
            b=7,
            gx=int(
                "79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F8"
                "1798", 16),
            gy=int(
                "483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10"
                "D4B8", 16),
            n=int(
                "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD036"
                "4141", 16),
            h=1),
    paranoid_pb2.CurveType.CURVE_BRAINPOOLP256R1:
        EcCurve(
            name="brainpoolP256r1",
            mod=int(
                "A9FB57DBA1EEA9BC3E660A909D838D726E3BF623D52620282013481D1F6E"
                "5377", 16),
            a=int(
                "7D5A0975FC2C3057EEF67530417AFFE7FB8055C126DC5C6CE94A4B44F330"
                "B5D9", 16),
            b=int(
                "26DC5C6CE94A4B44F330B5D9BBD77CBF958416295CF7E1CE6BCCDC18FF8C"
                "07B6", 16),
            gx=int(
                "8BD2AEB9CB7E57CB2C4B482FFC81B7AFB9DE27E1E3BD23C23A4453BD9ACE"
                "3262", 16),
            gy=int(
                "547EF835C3DAC4FD97F8461A14611DC9C27745132DED8E545C1D54C72F04"
                "6997", 16),
            n=int(
                "A9FB57DBA1EEA9BC3E660A909D838D718C397AA3B561A6F7901E0E829748"
                "56A7", 16),
        ),
    paranoid_pb2.CurveType.CURVE_BRAINPOOLP384R1:
        EcCurve(
            name="brainpoolP384r1",
            mod=int(
                "8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B412B1DA197FB7"
                "1123ACD3A729901D1A71874700133107EC53", 16),
            a=int(
                "7BC382C63D8C150C3C72080ACE05AFA0C2BEA28E4FB22787139165EFBA91"
                "F90F8AA5814A503AD4EB04A8C7DD22CE2826", 16),
            b=int(
                "04A8C7DD22CE28268B39B55416F0447C2FB77DE107DCD2A62E880EA53EEB"
                "62D57CB4390295DBC9943AB78696FA504C11", 16),
            gx=int(
                "1D1C64F068CF45FFA2A63A81B7C13F6B8847A3E77EF14FE3DB7FCAFE0CBD"
                "10E8E826E03436D646AAEF87B2E247D4AF1E", 16),
            gy=int(
                "8ABE1D7520F9C2A45CB1EB8E95CFD55262B70B29FEEC5864E19C054FF991"
                "29280E4646217791811142820341263C5315", 16),
            n=int(
                "8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B31F166E6CAC04"
                "25A7CF3AB6AF6B7FC3103B883202E9046565", 16),
            h=1),
    paranoid_pb2.CurveType.CURVE_BRAINPOOLP512R1:
        EcCurve(
            name="brainpoolP512r1",
            mod=int(
                "AADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA7033"
                "08717D4D9B009BC66842AECDA12AE6A380E62881FF2F2D82C68528AA6056"
                "583A48F3", 16),
            a=int(
                "7830A3318B603B89E2327145AC234CC594CBDD8D3DF91610A83441CAEA98"
                "63BC2DED5D5AA8253AA10A2EF1C98B9AC8B57F1117A72BF2C7B9E7C1AC4D"
                "77FC94CA", 16),
            b=int(
                "3DF91610A83441CAEA9863BC2DED5D5AA8253AA10A2EF1C98B9AC8B57F11"
                "17A72BF2C7B9E7C1AC4D77FC94CADC083E67984050B75EBAE5DD2809BD63"
                "8016F723", 16),
            gx=int(
                "81AEE4BDD82ED9645A21322E9C4C6A9385ED9F70B5D916C1B43B62EEF4D0"
                "098EFF3B1F78E2D0D48D50D1687B93B97D5F7C6D5047406A5E688B352209"
                "BCB9F822", 16),
            gy=int(
                "7DDE385D566332ECC0EABFA9CF7822FDF209F70024A57B1AA000C55B881F"
                "8111B2DCDE494A5F485E5BCA4BD88A2763AED1CA2B2FA8F0540678CD1E0F"
                "3AD80892", 16),
            n=int(
                "AADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA7033"
                "0870553E5C414CA92619418661197FAC10471DB1D381085DDADDB5879682"
                "9CA90069", 16),
            h=1),
    # Curves over binary fields.
    # Semaev proposes an algorithm for computing DLs in his paper
    # "New algorithm for the discrete logarithm problem on elliptic curves"
    # https://arxiv.org/abs/1504.01175
    # Hence these curves should be avoided.
    paranoid_pb2.CurveType.CURVE_SECT163K1:
        None,
    paranoid_pb2.CurveType.CURVE_SECT233K1:
        None,
    paranoid_pb2.CurveType.CURVE_SECT283K1:
        None,
    paranoid_pb2.CurveType.CURVE_SECT409K1:
        None,
    paranoid_pb2.CurveType.CURVE_SECT571K1:
        None,
    paranoid_pb2.CurveType.CURVE_SECT163R2:
        None,
    paranoid_pb2.CurveType.CURVE_SECT233R1:
        None,
    paranoid_pb2.CurveType.CURVE_SECT283R1:
        None,
    paranoid_pb2.CurveType.CURVE_SECT409R1:
        None,
    paranoid_pb2.CurveType.CURVE_SECT571R1:
        None,
}
